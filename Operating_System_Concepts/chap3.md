
## Chap 3. 프로세스

### 프로세스 개요
- 디스크에 있는 것은 프로그램, 메모리에 로드 된 것은 프로세스라고 함
- 실행하기 전까지는 그냥 프로그램
- 프로세스 실행은 순차적으로 진행되어야함
- 프로그램 카운터, stack, data section이 포함
- <img width="300" alt="스크린샷 2024-08-01 14 56 08" src="https://github.com/user-attachments/assets/259a744e-7362-40ff-9ee6-a4a30774d8b0">

### 프로세스 상태
- 프로세스는 실행되면 상태가 바뀜
- New - 프로세스가 처음 생성
- Ready - 프로세스가 프로세서에 할당되기를 기다리고 있음
- Running - 프로세스가 할당되어 실행되고 있음
- Waiting - 프로세스 일부 이벤트 발생을 기다리고 있음
- Terminated - 프로세스가 실행을 마침
- <img width="600" alt="스크린샷 2024-08-01 14 56 08" src="https://github.com/user-attachments/assets/45f0f7eb-4c51-4c29-ac28-9237b5534978">

### 프로세스 컨드롤 블록 (Process Control Block - PCB)
- 각 프로세스는 자신의 정보 묶음을 가지고 있음(PCB)
  - 프로세스 상태
  - 프로그램 카운터 - 해당 프로세스가 이어서 실행해야할 명령의 주소를 가리키는 카운터
  - CPU 레지스터 - 프로세스가 인터럽트 후 올바르게 작업을 이어가기 위해 참조하는 CPU 레지스터 값
  - CPU 스케줄링 정보 - 프로세스 스케줄링 파라미터 정보
  - 메모리 관리 정보
  - 어카운트 정보 - 사용된 CPU 총량, 프로세스 개수, 시간제한
  - I/O 상태 정보 - 입출력 장치 목록
---
### 프로세스 스케줄링
- 멀티프로그래밍 > 타임쉐어링 > 이어서 프로세스 스케줄러
- 프로세스 스케줄러는 CPU에서 프로그램의 실행을 위해 사용 가능한 프로세스를 선택 & 프로세스를 어떤 프로세서에 할당할 것인가 결정하는 일
### 프로세스 큐
- 프로세스가 시스템에 들어오면 job queue에 들어감
- Job Queue  - 시스템의 모든 프로세스로 구성
- Ready Queue - 메인 메모리에서 실행을 기다리는 ready 상태의 프로세스들 집합
- Device Queue - I/O 장치를 기다리는 프로세스들 집합
### 스케줄러
- short-term (= CPU 스케줄러)
  - 프로세스를 프로세서에 할당 하는 일
  - 매우, 자주 호출됨 (ms 단위)
- long-term (= Job 스케줄러)
  - 레디 큐에 프로세스를 옮기는 일
  - 드물게 호출됨 (min, sec 단위)
  - 멀티프로그래밍 결정(몇개 올릴건지?)
### I/O 바인딩 프로세스
- 계산보다 I/O 수행이 더 많음, 짧은 CPU 버스트가 많음
### CPU 바인딩 프로세스
- 계산에 더 많은 시간 소요, CPU 버스트가 적음
---
### 컨텍스트 스위치 (Context Switch)
- 프로세서가 다른 프로세스로 스위치 할때 발생
- 작업중이던 프로세스의 상태를 저장하고, 새로운 프로세스의 상태를 로드하는 과정
- 프로세스의 정보는 PCB에 저장됨
- 스위칭 되는 동안 시스템은 작동 x (= 오버헤드 발생 -> 자주 일어나면 성능 저하)
- context-switching 시간을 줄이는 것이 중
- <img width="600" alt="스크린샷 2024-08-01 14 56 08" src="https://github.com/user-attachments/assets/4d3d3c20-95e0-4aea-9a20-9cbfbbb12618">
---
### 프로세스 생성 (Process Creation)
- 부모 프로세스는 자식 프로세스 생성 - 이는 또 다른 프로세스 생성 => 트리 구조
- 자원공유 (resource sharing)
  - 부모 & 자식이 모든 리소스를 공유
  - 자식은 부모 리소스의 하위 집합을 공유
  - 부모 & 자식이 리소스를 공유하지 않음
- 실행 (execution)
  - 부모 & 자식은 동시에 실행 (병렬)
  - 부모는 일부/ 모든 자식이 실행 종료할 때까지 기다림 (wait())
- 주소지 (address space)
  - 자식은 부모로 부터 복제
  - 자식에게 프로그램이 로드되어 있음
- example)
  - 시스템 콜의 fork() 함수를 호출하면 부모 프로세스는 똑같은 자식 프로세스 생성
  - 자식 프로세스는 exec()를 통해 실행
  - exit()하면 기다리고 있는 부모 프로세스로 값 전달
  - <img width="600" alt="스크린샷 2024-08-01 14 56 08" src="https://github.com/user-attachments/assets/ba5c00fc-bfac-446e-a7a8-a84c3499b841">
  
  ### 프로세스 종료(Process Termination)
  - 프로세스는 exit()을 호출하고, 운영체제에 종료를 요청함
  - 비정상 종료 (abort)
    - 좀비(zombie) - 자식이 종료되었지만, 부모가 아직 wait()을 호출하지 않은 프로세스
    - 고아(orphan) - 부모가 wait()을 호출하지 않고 종료해버림
### 프로세스 간 통신 (Interprocess Communication, IPC)
- 프로세스가 소통하고 작업을 동기화 하는 메커니즘
- 메시지 전달(message passing) [우편] - 송신 프로세스가 수신 프로세스에게 커널을 통해 정보를 전달, 수신 프로세스도 커널에 접근해 정보를 수신
- 공유 메모리(shared memory) [게시판] - 특정 메모리 공간을 두 프로세스가 함께 사용하며 정보를 주고 받음
- <img width="600" alt="스크린샷 2024-08-01 14 56 08" src="https://github.com/user-attachments/assets/3d2b46fa-c63b-4c4f-8dde-d0f61a418ab5">

### 생산자 - 소비자 간의 이슈
- 생산자, 소비자 두 프로세스가 동시에 동작할 때 일어나는 이슈
- 정보가 생산되는 속도보다 소비하는 속도가 빠를때 동기화 문제 발생 -> 버퍼를 사용(데이터를 담아두는 역할)
- 고정된 버퍼 크기 - bound-buffer
- 크기 제한을 두지 않는 버퍼 - unbounded-buffer
- <img width="600" alt="스크린샷 2024-08-01 14 56 08" src="https://github.com/user-attachments/assets/6e826106-5529-485a-8231-da29c24c89a5">



 
